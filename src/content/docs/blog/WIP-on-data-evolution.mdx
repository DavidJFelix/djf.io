---
title: 'On Data Evolution'
subtitle: 'Schemas, Types, Structures, and Versioning'
author: DavidJFelix
description: 'Schemas, Types, Structures and Versioning'
date: 2023-12-30
tags:
  - data
  - types
  - safety
  - sdlc
  - software
readingTime: 5m
hero:
  tagline: 'Schemas, Types, Structures and Versioning'
  image:
    file: ../../../assets/shipposting-hero.png
    alt: ''
---

import {Tabs, TabItem} from '@astrojs/starlight/components'

## ALL data has structure

Regardless of if you define the structure ahead of time, all data has some structure.
Well-structured data is more immediately usable, but even randomly assembled data has structure.
For the sake of this article, we'll work with structures that are a little more sensible than an array of bits.
I'll work with strongly typed languages with types statically defined rather than interpreted or parsed, but it's important to remember that this is possible with more complex types.

## All things are data

We build data structures everywhere.
They are pervasive whether we explicitly define what they look like or implicitly rely on them.
Data is in primitive types, structured data, and even function signatures.
Statically typed languages allow us to pry into the structure and name the types we're working with, which helps when discussing migrations.
For example, if we were defining an early `User` structure, here's what it might look like for TypeScript/JSON, SQLite, and Protobuf/go.

<Tabs>
  <TabItem label="TypeScript">

```typescript
type User = {
  id: string
  name: string
}

const user: User = {
  id: 'user_2x4y6z8a0b1c2d3e4f5g6h7j8k',
  name: 'David J Felix',
}
```

  </TabItem>
  <TabItem label="SQLite">

    ```sql
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY NOT NULL,
      name TEXT NOT NULL
    );

    INSERT INTO users (
      id,
      name
    ) VALUES (
      'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
      'David J Felix'
    );
    ```

  </TabItem>
  <TabItem label="Protobuf">

    Protobuf:

    ```proto
    message User {
      string id = 1;
      string name = 2;
    }
    ```

    Go:

    ```go
    user := pb.User{
        Id:   "user_2x4y6z8a0b1c2d3e4f5g6h7j8",
        Name: "David J Felix",
    }
    ```

  </TabItem>
</Tabs>

## The way we talk about data changes over time

### Sometimes the structure must change to accommodate that

### Changing structures can damage usability between versions

## We should make migrations first class

### Codified and lazy migrations help

    #### Allow data to exist in multiple versions

### We should refer to structures immutably

    #### This allows us to continuously manage old versions

- Changing the structure of the data is part of the lifecycle of applications

<Tabs>
  <TabItem label="TypeScript">

    ```typescript
    type User = {
      id: string
      name: string
      email: string
    }

    const user: User = {
      id: 'user_2x4y6z8a0b1c2d3e4f5g6h7j8k',
      name: 'David J Felix',
      email: 'blog@djf.io',
    }
    ```

  </TabItem>
  <TabItem label="SQLite">

    ```sql
    -- For an existing database this won't run because EXISTS = true
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY NOT NULL,
      name TEXT NOT NULL
    );
    ALTER TABLE users ADD email TEXT NOT NULL DEFAULT '';

    INSERT INTO users (
      id,
      name,
      email
    ) VALUES (
      'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
      'David J Felix',
      'blog@djf.io'
    );
    ```

  </TabItem>
  <TabItem label="Protobuf">

    Protobuf:

    ```proto
    message User {
      string id = 1;
      string name = 2;
      string email = 3;
    }
    ```

    Go:

    ```go
    user := pb.User{
        Id:    "user_2x4y6z8a0b1c2d3e4f5g6h7j8",
        Name:  "David J Felix",
        Email: "blog@djf.io",
    }
    ```

  </TabItem>
</Tabs>

- Protobuf advises you don't do this since it's a breaking change that will break backwards compatibility with old clients.
- There's a difference in immediacy. SQL has a concept of altering data.
- With SQL we have to address existing data. `DEFAULT ''` is used to accommodate existing rows that don't currently have an email but need to meet the constraint that the column be `NOT NULL`.
- This means it's still backwards compatible but perhaps not perfectly because the empty value isn't really much more meaningful than null.
- Typescript might feel immune to these issues but values saved in `localstorage`, JSON fetched from older APIs, ir data in KV/Object/Document storage
- Likewise, if we were to build a rollback migration it might look like

```sql
ALTER TABLE users DROP email;
```

- This more explicitly handles some of the edge cases with versioning some DDLs like protobuf have documentation that advise against adding required fields since they don't allow for defaults in the DDL and it will be a breaking change for clients that omit it.
- While adding a column has an explicit migration data fill from `undefined` -> `''` with `DEFAULT ''`, drop has an implicit migration from `'blog@djf.io` -> `undefined`

- Protobuf advises this:

<Tabs>
  <TabItem label="TypeScript">

    ```typescript
    type User = {
      id: string
      name: string
      email?: string
    }
    ```

  </TabItem>
  <TabItem label="SQLite">
  
    ```sql
    ALTER TABLE users ADD email TEXT DEFAULT NULL;
    ```

  </TabItem>
  <TabItem label="Protobuf">

    ```proto
    message User {
      string id = 1;
      string name = 2;
      optional string email = 3;
    }
    ```

  </TabItem>
</Tabs>

- I think this is a debatable tactic for SQLite and less desirable for typescript.
- Protobuf handles this nicely since the code generation is the same and uses default values. This is similar to SQLite.
- I think the SQLite tactic is debatable because it pushes the default behavior to the application code. For empty string, it might as well be null (but now requires null checks).
  - For booleans you have to decide which default is correct
  - For enums you have to decide which state is default.

No rollback migration is necessary but it could be used.

The pain here happens if you rollback or otherwise remove or change the type of the `email` column elsewhere -- it pushes the problem.
Suppose your migration isn't quite the same.

# this is where my thoughts go rogue

<Tabs>
  <TabItem label="SQLite Migration">
  
    ```sql
    ALTER TABLE users ADD family_name TEXT DEFAULT  ;
    ```

  </TabItem>
  <TabItem label="SQLite Rollback Migration">

    ```proto
    message User {
      string id = 1;
      string name = 2;
      optional string email = 3;
    }
    ```

  </TabItem>
</Tabs>

```sql
CREATE TABLE IF NOT EXISTS schema_mappings (
  schema_version TEXT NOT NULL,
  field_name TEXT NOT NULL,
  column_name TEXT NOT NULL,
  PRIMARY KEY (schema_version, field_name)
);
-- Put
INSERT INTO schema_mappings (
  schema_version,
  field_name,
  column_name
) VALUES (
  '0001',
  'id',
  'id',
);

ALTER TABLE users ADD email_0001 TEXT DEFAULT NULL;
INSERT INTO schema_mappings (
  schema_version,
  field_name,
  column_name
) VALUES (
  '0001',
  'email',
  'email_0001'
);

-- Older clients
SELECT id, name FROM users;
INSERT INTO users (
  id,
  name
) VALUES (
  'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
  'David J Felix'
);

-- Newer clients
SELECT id, name, email_0001 AS email FROM users;
INSERT INTO users (
  id,
  name,
  email_0001
) VALUES (
  'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
  'David J Felix',
  'blog@djf.io'
);
```

I propose

```typescript
type User0001 = {
  id: string
  name: string
}

type User0002 = {
  id: string
  givenName: string
  familyName: string
}

function fromUser0001ToUser0002(user: User0001): User0002 {
  const {id, name} = user
  return {
    id,
    givenName: name.split(' '),
    familyName: name.split(' '),
  }
}

function fromUser0002ToUser0001(user: User0002): User0001 {
  const {id, givenName, familyName} = user
  return {
    id,
    name: `${givenName} ${familyName}`,
  }
}
```

what if it was possible to encapsulate this into a meta type with:

```typescript
type User = (
  version: '0001'
  inner: User0001
) | (
  version: '0002'
  inner: User0002
)
```

Which could be used consistently as data evolves:

```typescript
const newUser: User = {
  version: '0002',
  inner: {
    id: 'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
    givenName: 'David J'
    familyName:  'Felix',
  }
}
```

I could get an old version of user if I had logic that depended on that:

```typescript
const oldUser = migrateTo<'0001'>(newUser)
console.log(oldUser.name) // No more pesky logic upgrades!
```

So could this be done?

With SQLite we have a snapshot of the current schema applied to all of our data. It's maybe not natively possible with SQLite, native SQL examples exist for MySQL, Postgres and Vitess.
Vitess has online schema migrations, postgres could use materialized views and MySQL can use gh-ost to make ghost tables.
With SQLite we could push the behavior clientside and constantly add fields, making tables wider.

With typescript, we could parse types for our schema objects and create lock files for those types based on a hash and output a discriminated variant
