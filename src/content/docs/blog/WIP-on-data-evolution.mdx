---
title: 'On Data Evolution'
subtitle: 'Schemas, Types, Structures and Versioning'
author: DavidJFelix
description: 'Schemas, Types, Structures and Versioning'
date: 2023-12-30
tags:
  - data
  - types
  - safety
  - sdlc
  - software
readingTime: 5m
hero:
  tagline: 'Schemas, Types, Structures and Versioning'
  image:
    file: ../../../assets/shipposting-hero.png
    alt: ''
---

import {Tabs, TabItem} from '@astrojs/starlight/components'

## The Structure of Data

There are many ways to structure data.
For the sake of this post, I'm going to refer to strongly typed languages since we'll be discussing the structure directly and how it evolves.
Strong typing makes that a little easier since the type is explicit.

We build structures everywhere and define what the look like in a number of different ways.
For example, if we were defining an early `User` structure here's what it might look like for TypeScript/JSON, SQLite and Protobuf/go.

<Tabs>
  <TabItem label="TypeScript">

```typescript
type User = {
  id: string
  name: string
}

const user: User = {
  id: 'user_2x4y6z8a0b1c2d3e4f5g6h7j8k',
  name: 'David J Felix',
}
```

  </TabItem>
  <TabItem label="SQLite">

    ```sql
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY NOT NULL,
      name TEXT NOT NULL
    );

    INSERT INTO users (
      id,
      name
    ) VALUES (
      'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
      'David J Felix'
    );
    ```

  </TabItem>
  <TabItem label="Protobuf">

    Protobuf:

    ```proto
    message User {
      string id = 1;
      string name = 2;
    }
    ```

    Go:

    ```go
    user := pb.User{
        Id:   "user_2x4y6z8a0b1c2d3e4f5g6h7j8",
        Name: "David J Felix",
    }
    ```

  </TabItem>
</Tabs>

- Whether you use a map or a tuple, a list or a struct, the data has structure.
- Structure and patterns give data greater value and capabilities

- Changing the structure of the data is part of the lifecycle of applications

<Tabs>
  <TabItem label="TypeScript">

    ```typescript
    type User = {
      id: string
      name: string
      email: string
    }

    const user: User = {
      id: 'user_2x4y6z8a0b1c2d3e4f5g6h7j8k',
      name: 'David J Felix',
      email: 'blog@djf.io',
    }
    ```

  </TabItem>
  <TabItem label="SQLite">

    ```sql
    -- For an existing database this won't run because EXISTS = true
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY NOT NULL,
      name TEXT NOT NULL
    );
    ALTER TABLE users ADD email TEXT NOT NULL DEFAULT '';

    INSERT INTO users (
      id,
      name,
      email
    ) VALUES (
      'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
      'David J Felix',
      'blog@djf.io'
    );
    ```

  </TabItem>
  <TabItem label="Protobuf">

    Protobuf:

    ```proto
    message User {
      string id = 1;
      string name = 2;
      string email = 3;
    }
    ```

    Go:

    ```go
    user := pb.User{
        Id:    "user_2x4y6z8a0b1c2d3e4f5g6h7j8",
        Name:  "David J Felix",
        Email: "blog@djf.io",
    }
    ```

  </TabItem>
</Tabs>

- Protobuf advises you don't do this since it's a breaking change that will break backwards compatibility with old clients.
- There's a difference in immediacy. SQL has a concept of altering data.
- With SQL we have to address existing data. `DEFAULT ''` is used to accommodate existing rows that don't currently have an email but need to meet the constraint that the column be `NOT NULL`.
- This means it's still backwards compatible but perhaps not perfectly because the empty value isn't really much more meaningful than null.
- Typescript might feel immune to these issues but values saved in `localstorage`, JSON fetched from older APIs, ir data in KV/Object/Document storage
- Likewise, if we were to build a rollback migration it might look like

```sql
ALTER TABLE users DROP email;
```

- This more explicitly handles some of the edge cases with versioning some DDLs like protobuf have documentation that advise against adding required fields since they don't allow for defaults in the DDL and it will be a breaking change for clients that omit it.
- While adding a column has an explicit migration data fill from `undefined` -> `''` with `DEFAULT ''`, drop has an implicit migration from `'blog@djf.io` -> `undefined`

- Protobuf advises this:

<Tabs>
  <TabItem label="TypeScript">

    ```typescript
    type User = {
      id: string
      name: string
      email?: string
    }
    ```

  </TabItem>
  <TabItem label="SQLite">
  
    ```sql
    ALTER TABLE users ADD email TEXT DEFAULT NULL;
    ```

  </TabItem>
  <TabItem label="Protobuf">

    ```proto
    message User {
      string id = 1;
      string name = 2;
      optional string email = 3;
    }
    ```

  </TabItem>
</Tabs>

- I think this is a debatable tactic for SQLite and less desirable for typescript.
- Protobuf handles this nicely since the code generation is the same and uses default values. This is similar to SQLite.
- I think the SQLite tactic is debatable because it pushes the default behavior to the application code. For empty string, it might as well be null (but now requires null checks).
  - For booleans you have to decide which default is correct
  - For enums you have to decide which state is default.

No rollback migration is necessary but it could be used.

The pain here happens if you rollback or otherwise remove or change the type of the `email` column elsewhere -- it pushes the problem.
Suppose your migration isn't quite the same.

# this is where my thoughts go rogue

<Tabs>
  <TabItem label="SQLite Migration">
  
    ```sql
    ALTER TABLE users ADD family_name TEXT DEFAULT  ;
    ```

  </TabItem>
  <TabItem label="SQLite Rollback Migration">

    ```proto
    message User {
      string id = 1;
      string name = 2;
      optional string email = 3;
    }
    ```

  </TabItem>
</Tabs>

```sql
CREATE TABLE IF NOT EXISTS schema_mappings (
  schema_version TEXT NOT NULL,
  field_name TEXT NOT NULL,
  column_name TEXT NOT NULL,
  PRIMARY KEY (schema_version, field_name)
);
-- Put
INSERT INTO schema_mappings (
  schema_version,
  field_name,
  column_name
) VALUES (
  '0001',
  'id',
  'id',
);

ALTER TABLE users ADD email_0001 TEXT DEFAULT NULL;
INSERT INTO schema_mappings (
  schema_version,
  field_name,
  column_name
) VALUES (
  '0001',
  'email',
  'email_0001'
);

-- Older clients
SELECT id, name FROM users;
INSERT INTO users (
  id,
  name
) VALUES (
  'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
  'David J Felix'
);

-- Newer clients
SELECT id, name, email_0001 AS email FROM users;
INSERT INTO users (
  id,
  name,
  email_0001
) VALUES (
  'user_2x4y6z8a0b1c2d3e4f5g6h7j8',
  'David J Felix',
  'blog@djf.io'
);
```

I propose

```typescript
type User0001 = {
  id: string
  name: string
}

type User0002 = {
  id: string
  givenName: string
  familyName: string
}

function fromUser0001ToUser0002(user: User0001): User0002 {
  const {id, name} = user
  return {
    id,
    givenName: name.split(' '),
    familyName: name.split(' '),
  }
}

function fromUser0002ToUser0001(user: User0002): User0001 {
  const {id, givenName, familyName} = user
  return {
    id,
    name: `${givenName} ${familyName}`,
  }
}
```

what if it was possible to encapsulate this into a meta type with:

```typescript
type User = (
  version: '0001'
  inner: User0001
) | (
  version: '0002'
  inner: User0002
)
```
